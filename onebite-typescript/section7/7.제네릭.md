# 7. 제네릭

## 0. 제네릭 소개
- 제네릭 : 함수나 인터페이스, 타입 별칭, 클래스 등을 다양한 타입과 함께 동작하도록 만들어주는 기능


### 제네릭이 필요한 상황
```typescript
function func(value: any) {
  return value;
}

let num = func(10);
// any 타입

let str = func("string");
// any 타입

num.toUpperCase(); // 런타임 오류 발생!!
```

```typescript
// unknown 타입으로 정의
function func(value: unknown) {
  return value;
}

let num = func(10);
// unknown 타입

let str = func("string");
// unknown 타입

num.toUpperCase(); // ❌
num.toFixed(); // ❌

// toUpperCase 메서드 호출 방지할 수 있으나, Number타입의 메서드 호출도 오류로 판단하게 됨
```

```typescript
// 따라서 비효율적으로 타입 좁히기를 해야함

function func(value: unknown) {
  return value;
}

let num = func(10);
// unknown 타입

let str = func("string");
// unknown 타입

if (typeof num === "number") {
  num.toFixed();
}
```

### 제네릭(Generic) 함수
- 일반적인 또는 포괄적인 함수로 해석
- 두루두루 모든 타입의 값을 다 적용할 수 있는 범용적인 함수

- T에 어떤 타입이 할당될지는 함수가 호출될 때 결정됨

```typescript
function func<T>(value: T): T {
  return value;
}

let num = func(10);
// number 타입
```

![image](https://github.com/devjjin/ts-study/assets/38846447/2def62c0-a1e0-40a8-835e-00f4c22092be)

```typescript
function func<T>(value: T): T {
  return value;
}

let arr = func<[number, number, number]>([1, 2, 3]);

// T에 [Number, Number, Number] 튜플 타입이 할당됨
// 매개변수 value와 반환값 타입이 모두 튜플 타입이 됨
```

## 1. 타입 변수 응용하기

### 사례1
- 2개의 타입변수가 필요한 상황
  
```typescript
function swap<T, U>(a: T, b: U) {
  return [b, a];
}

const [a, b] = swap("1", 2);
// T는 String, U는 Number타입으로 추론됨
```

### 사례2
-  배열 타입을 인수로 받는 제네릭 함수
```typescript
function returnFirstValue<T>(data: T[]) {
  return data[0];
}

let num = returnFirstValue([0, 1, 2]);
// number

let str = returnFirstValue([1, "hello", "mynameis"]);
// number | string

// 매개변수 data타입은 T[]로 배열이 아닌 값은 인수로 전달할 수 없게 됨
// T는 num은 Number타입으로 추론됨
// T는 String | Number 타입으로 추론됨
```

### 사례3
- 반환값의 타입을 배열의 첫번째 요소의 타입이 되도록 하려면 튜플 타입과 나머지 파라미터 이
```typescript
function returnFirstValue<T>(data: [T, ...unknown[]]) {
  return data[0];
}

let str = returnFirstValue([1, "hello", "mynameis"]);
// number
```

### 사례4
- 타입 변수 제한 : 함수를 호출하고 인수로 전달할 수 있는 값의 범위에 제한을 두는 것
- 타입 변수를 제한할 때에는 확장(extends)을 이용

```typescript
function getLength<T extends { length: number }>(data: T) {
  return data.length;
}

getLength("123");            // ✅

getLength([1, 2, 3]);        // ✅

getLength({ length: 1 });    // ✅

getLength(undefined);        // ❌

getLength(null);             // ❌
```

## 2. map, forEach 메서드 타입 정의하기
### Map 메서드 타입 정의하기

```typescript
const arr = [1, 2, 3];
const newArr = arr.map((it) => it * 2);
// [2, 4, 6]
```

```typescript
function map(arr: unknown[], callback: (item: unknown) => unknown): unknown[] {}
// 메서드를 적용할 배열을 매개변수 arr로 받고 콜백함수를 매개변수 callback으로 받음
```

```typescript
// 제네릭 함수로 만들기
function map<T>(arr: T[], callback: (item: T) => T): T[] {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(callback(arr[i]));
  }
  return result;
}
```

```typescript
const arr = [1, 2, 3];

function map<T>(arr: T[], callback: (item: T) => T): T[] {
  (...)
}

map(arr, (it) => it.toString()); // ❌
```

### ForEach 메서드 타입 정의하기
```typescript
const arr2 = [1, 2, 3];

arr2.forEach((it) => console.log(it));
// 출력 : 1, 2, 3
```

```typescript
function forEach<T>(arr: T[], callback: (item: T) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i]);
  }
}
```


## 3. 제네릭 인터페이스, 제네릭 탕입 별칭
## 4. 제네릭 클래스
## 5. 프로미스와 제네릭
