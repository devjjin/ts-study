# 9. 조건부 타입

## 0. 조건부 타입
- extends와 삼항 연산자를 이용해 조건에 따라 각각 다른 타입을 정의하도록 돕는 문법

```typescript
type A = number extends string ? number : string;

// number타입이 string 타입의 서브타입이 아니므로, 조건은 거짓이 됨 -> A는 string 타입이됨
```

- 객체 타입에 적용
```typescript
type ObjA = {
  a: number;
};

type ObjB = {
  a: number;
  b: number;
};

type B = ObjB extends ObjA ? number : string;

// ObjB는 ObjA의 서브타입이므로 조건식이 참이 됨 -> B는 number 타입이 됨
```

### 제네릭 조건부 타입
- 조건부 타입은 제네릭과 함께 사용할 때 위력이 극대화 됨
  
```typescript
type StringNumberSwitch<T> = T extends number ? string : number;

let varA: StringNumberSwitch<number>;
// string , 조건식 참

let varB: StringNumberSwitch<string>;
// number, 조건식 거짓
```

```typescript
function removeSpaces(text: string) {
  return text.replaceAll(" ", "");
}

let result = removeSpaces("hi im winterlood");
```

```typescript
function removeSpaces(text: string | undefined | null) {
  return text.replaceAll(" ", ""); // ❌ 오류 발생, text가 string이 아닐 수 있음
}

let result = removeSpaces("hi im winterlood");
```

```typescript
// 타입좁히기
function removeSpaces(text: string | undefined | null) {
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood"); // string | undefined
```

```typescript
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  // 조건문 타입의 결과를 함수 내부에서 알 수 없으므로, 에러 발생
  if (typeof text === "string") {
    return text.replaceAll(" ", ""); // ❌
  } else {
    return undefined; // ❌
  }
} 

let result = removeSpaces("hi im winterlood"); // string
let result2 = removeSpaces(undefined); // undefined
```

```typescript
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  // 타입단언을 이용해 반환값을 any 타입으로 단언 -> but any타입으로 단언하면 string이 아닌 타입을 반환해도 오류 감지 못함
  if (typeof text === "string") {
    return text.replaceAll(" ", "") as any;
  } else {
    return undefined as any;
  }
}

let result = removeSpaces("hi im winterlood"); // string
let result2 = removeSpaces(undefined); // undefined
```

```typescript
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  if (typeof text === "string") {
    return 0 as any; // 문제 감지 못함
  } else {
    return undefined as any;
  }
}

let result = removeSpaces("hi im winterlood"); // string
let result2 = removeSpaces(undefined); // undefined
```

- 따라서 함수 오버로딩을 사용하는 것이 좋음
- 오버로드 시그니처의 조건부타입은 시그니쳐 내부에서 추론 가능
  
```typescript
function removeSpaces<T>(text: T): T extends string ? string : undefined;
function removeSpaces(text: any) {
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood"); // string
let result2 = removeSpaces(undefined); // undefined
```




## 1. 분산적인 조건부 타입
## 2. infer
